import { CalculationOutput, SimulationParams, YearlyDetail } from "../types";

// Helper for strict 2-decimal rounding to prevent floating point drift
const round2 = (num: number): number => Math.round(num * 100) / 100;

export const safeParseFloat = (val: any, defaultVal: number = 0): number => {
  if (val === undefined || val === null || val === "") return defaultVal;
  const str = String(val).replace(",", ".").replace(/\s/g, "");
  const parsed = parseFloat(str);
  return isNaN(parsed) ? defaultVal : parsed;
};

export const formatCurrency = (value: number): string => {
  return new Intl.NumberFormat("fr-FR", {
    style: "currency",
    currency: "EUR",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
};

export const calculateSolarProjection = (
  params: SimulationParams,
  overrides: {
    inflationRate: number;
    projectionYears: number;
    electricityPrice: number;
    yearlyProduction: number;
    selfConsumptionRate: number;
    installCost: number;
    cashApport: number;
    remainingToFinance: number;
    creditMonthlyPayment: number;
    insuranceMonthlyPayment: number;
    creditDurationMonths: number;
    taxRate?: number;
    buybackRate?: number;
  }
): CalculationOutput => {
  const currentAnnualBill = safeParseFloat(params.currentAnnualBill, 0);
  const yearlyConsumption = safeParseFloat(params.yearlyConsumption, 0);

  // Destructure overrides with a fallback to prevent "Missing initializer" error
  const {
    inflationRate = 5,
    projectionYears = 20,
    electricityPrice = 0.25,
    yearlyProduction = 7000,
    selfConsumptionRate = 70,
    installCost = 18799,
    creditMonthlyPayment = 138.01,
    insuranceMonthlyPayment = 4.7,
    creditDurationMonths = 180,
    taxRate = 0,
    buybackRate = 0.04,
  } = overrides || {};

  const cashApport = overrides?.cashApport ?? 0;

  // Normalized inputs
  const localInflation = round2(inflationRate);
  const localInstallCost = round2(installCost);

  // --- BASE CALCULATIONS ---
  // 1. Consumption Base
  const baseConsumptionKwh =
    yearlyConsumption > 0
      ? yearlyConsumption
      : electricityPrice > 0
      ? currentAnnualBill / electricityPrice
      : 0;

  // 2. Production Split
  const selfConsumedKwh = round2(
    yearlyProduction * (selfConsumptionRate / 100)
  );
  const surplusKwh = round2(yearlyProduction - selfConsumedKwh);

  // âœ… CORRECTION 1: Calculer la revente de BASE (sera indexÃ©e dans la boucle)
  // Note: La taxe n'est PAS appliquÃ©e sur la revente
  const surplusRevenueBase = round2(surplusKwh * buybackRate);

  // âš ï¸ SUPPRIMÃ‰: const surplusRevenuePerYear = round2(netSurplusRevenue);
  // Cette valeur sera calculÃ©e dans la boucle avec l'inflation

  const savingsRatePercent =
    baseConsumptionKwh > 0
      ? round2((selfConsumedKwh / baseConsumptionKwh) * 100)
      : 0;

  // --- SIMULATION LOOPS ---
  const startYear = new Date().getFullYear();

  // Storage for Credit Scenario
  const details: YearlyDetail[] = [];
  let cumulativeSpendNoSolar = 0; // Pas d'arrondi intermÃ©diaire
  let cumulativeSpendSolar = cashApport; // Commence Ã  0 pour financement

  // Storage for Cash Scenario
  const detailsCash: YearlyDetail[] = [];
  let cumulativeSpendNoSolarCash = 0; // Pas d'arrondi intermÃ©diaire
  let cumulativeSpendSolarCash = localInstallCost; // Investissement initial

  // Run projection for 30 years (standard lifetime)
  for (let i = 0; i < 30; i++) {
    const year = startYear + i;

    // Inflation factor
    const priceMultiplier = Math.pow(1 + localInflation / 100, i);
    const currentPrice = round2(electricityPrice * priceMultiplier);

    // âœ… CORRECTION 1b: Appliquer l'inflation Ã  la revente
    const surplusRevenuePerYear = round2(surplusRevenueBase * priceMultiplier);

    // A. SCENARIO: NO SOLAR
    const billWithoutSolar = round2(baseConsumptionKwh * currentPrice);

    // B. SCENARIO: WITH SOLAR (COMMON)
    const savingsInEuros = round2(selfConsumedKwh * currentPrice);
    const residuaryBill = Math.max(
      0,
      round2(billWithoutSolar - savingsInEuros)
    );

    // Total raw value generated by the system (Savings + Resale)
    const solarSavingsValue = round2(savingsInEuros + surplusRevenuePerYear);

    // C. CREDIT SPECIFICS
    // Precise monthly calculation to match validation script
    const startMonthOfLoan = 0;
    const endMonthOfLoan = creditDurationMonths;
    const yearStartMonth = i * 12;
    const yearEndMonth = (i + 1) * 12;
    const activeStart = Math.max(yearStartMonth, startMonthOfLoan);
    const activeEnd = Math.min(yearEndMonth, endMonthOfLoan);
    const monthsActiveInYear = Math.max(0, activeEnd - activeStart);

    const creditCostYearly =
      monthsActiveInYear > 0
        ? round2(
            (creditMonthlyPayment + insuranceMonthlyPayment) *
              monthsActiveInYear
          )
        : 0;

    // Cashflow Credit
    // Total DÃ©caissÃ© = Bill residue + Loan + Insurance - Resale Revenue
    const totalDecaisse = round2(
      residuaryBill + creditCostYearly - surplusRevenuePerYear
    );
    const yearlyCashflow = round2(billWithoutSolar - totalDecaisse);

    // âœ… CORRECTION 2 & 3: Cumuls sans round2() intermÃ©diaire
    cumulativeSpendNoSolar = cumulativeSpendNoSolar + billWithoutSolar;
    cumulativeSpendSolar = cumulativeSpendSolar + totalDecaisse;

    // âœ… CORRECTION 2b: Simplification du calcul
    const cumulativeSavings = cumulativeSpendNoSolar - cumulativeSpendSolar;

    details.push({
      year,
      edfBillWithoutSolar: round2(billWithoutSolar),
      creditPayment: round2(creditCostYearly),
      edfResidue: round2(residuaryBill),
      totalWithSolar: round2(totalDecaisse),
      cumulativeSavings: round2(cumulativeSavings), // âœ… Arrondi Ã  l'affichage uniquement
      cumulativeSpendNoSolar: round2(cumulativeSpendNoSolar),
      cumulativeSpendSolar: round2(cumulativeSpendSolar),
      cashflowDiff: round2(yearlyCashflow),
      solarSavingsValue: round2(solarSavingsValue),
    });

    // D. CASH SPECIFICS
    const totalDecaisseCash = round2(residuaryBill - surplusRevenuePerYear);
    const yearlyCashflowCash = round2(billWithoutSolar - totalDecaisseCash);

    // âœ… CORRECTION 2 & 3: MÃªme logique pour le cash
    cumulativeSpendNoSolarCash = cumulativeSpendNoSolarCash + billWithoutSolar;
    cumulativeSpendSolarCash = cumulativeSpendSolarCash + totalDecaisseCash;

    // âœ… CORRECTION 2b: Simplification
    const cumulativeSavingsCash =
      cumulativeSpendNoSolarCash - cumulativeSpendSolarCash;

    detailsCash.push({
      year,
      edfBillWithoutSolar: round2(billWithoutSolar),
      creditPayment: 0,
      edfResidue: round2(residuaryBill),
      totalWithSolar: round2(totalDecaisseCash),
      cumulativeSavings: round2(cumulativeSavingsCash), // âœ… Arrondi Ã  l'affichage
      cumulativeSpendNoSolar: round2(cumulativeSpendNoSolarCash),
      cumulativeSpendSolar: round2(cumulativeSpendSolarCash),
      cashflowDiff: round2(yearlyCashflowCash),
      solarSavingsValue: round2(solarSavingsValue),
    });
  }

  // --- AGGREGATES ---
  const slicedDetails = details.slice(0, projectionYears);
  const slicedDetailsCash = detailsCash.slice(0, projectionYears);

  // Projections Credit
  const totalSavingsProjected =
    slicedDetails.length > 0
      ? slicedDetails[slicedDetails.length - 1].cumulativeSavings
      : 0;
  const totalSpendNoSolar =
    slicedDetails.length > 0
      ? slicedDetails[slicedDetails.length - 1].cumulativeSpendNoSolar
      : 0;
  const totalSpendSolar =
    slicedDetails.length > 0
      ? slicedDetails[slicedDetails.length - 1].cumulativeSpendSolar
      : 0;

  const breakEvenYearIndex = details.findIndex((d) => d.cumulativeSavings > 0);
  const breakEvenPoint =
    breakEvenYearIndex !== -1 ? breakEvenYearIndex + 1 : 30;

  // Projections Cash
  const totalSavingsProjectedCash =
    slicedDetailsCash.length > 0
      ? slicedDetailsCash[slicedDetailsCash.length - 1].cumulativeSavings
      : 0;
  const totalSpendNoSolarCash =
    slicedDetailsCash.length > 0
      ? slicedDetailsCash[slicedDetailsCash.length - 1].cumulativeSpendNoSolar
      : 0;
  const totalSpendSolarCash =
    slicedDetailsCash.length > 0
      ? slicedDetailsCash[slicedDetailsCash.length - 1].cumulativeSpendSolar
      : 0;
  const breakEvenYearIndexCash = detailsCash.findIndex(
    (d) => d.cumulativeSavings > 0
  );
  const breakEvenPointCash =
    breakEvenYearIndexCash !== -1 ? breakEvenYearIndexCash + 1 : 30;

  // KPIs
  const year1 =
    details.length > 0
      ? details[0]
      : {
          totalWithSolar: 0,
          edfBillWithoutSolar: 0,
          creditPayment: 0,
          edfResidue: 0,
          cumulativeSavings: 0,
          cumulativeSpendNoSolar: 0,
          cumulativeSpendSolar: 0,
          cashflowDiff: 0,
          solarSavingsValue: 0,
          year: startYear,
        };

  const newMonthlyBillYear1 = round2(year1.totalWithSolar / 12);
  const oldMonthlyBillYear1 = round2(year1.edfBillWithoutSolar / 12);
  const monthlyEffortYear1 = round2(newMonthlyBillYear1 - oldMonthlyBillYear1);

  const averageYearlyGain =
    projectionYears > 0 ? round2(totalSavingsProjected / projectionYears) : 0;
  const averageYearlyGainCash =
    projectionYears > 0
      ? round2(totalSavingsProjectedCash / projectionYears)
      : 0;

  const costOfInactionPerSecond = Math.max(
    0.0001,
    averageYearlyGain / (365 * 24 * 3600)
  );

  const effectiveCost = localInstallCost > 0 ? localInstallCost : 20000;

  // ROI calculations (conservÃ©s pour compatibilitÃ©)
  const roiPercentage =
    effectiveCost > 0
      ? Math.round((averageYearlyGain / effectiveCost) * 1000) / 10
      : 0;

  const roiPercentageCash =
    localInstallCost > 0
      ? Math.round((averageYearlyGainCash / localInstallCost) * 1000) / 10
      : 0;

  const bankEquivalentCapital = round2(averageYearlyGain / 0.027);
  const bankEquivalentCapitalCash = round2(averageYearlyGainCash / 0.027);

  // Next Year Loss
  const priceNextYear = round2(
    electricityPrice * Math.pow(1 + localInflation / 100, 1)
  );
  const lossIfWait1Year = round2(baseConsumptionKwh * priceNextYear);
  const savingsLostIfWait1Year = round2(selfConsumedKwh * priceNextYear);

  // âœ… NOUVEAU: Calculer surplusRevenuePerYear pour l'annÃ©e 1 (pour compatibilitÃ© avec les autres composants)
  const surplusRevenuePerYearOutput = round2(
    surplusRevenueBase * Math.pow(1 + localInflation / 100, 0)
  );

  return {
    details,
    slicedDetails,
    detailsCash,
    slicedDetailsCash,

    totalSavingsProjected,
    totalSpendNoSolar,
    totalSpendSolar,

    totalSavingsProjectedCash,
    totalSpendNoSolarCash,
    totalSpendSolarCash,

    breakEvenPoint,
    breakEvenPointCash,

    costOfInactionPerSecond,
    averageYearlyGain,
    averageYearlyGainCash,

    newMonthlyBillYear1,
    oldMonthlyBillYear1,
    monthlyEffortYear1,

    roiPercentage,
    roiPercentageCash,

    bankEquivalentCapital,
    bankEquivalentCapitalCash,

    savingsRatePercent,
    baseConsumptionKwh,
    lossIfWait1Year,
    savingsLostIfWait1Year,
    surplusRevenuePerYear: surplusRevenuePerYearOutput, // âœ… Valeur pour annÃ©e 1
    year1,
  };
};

export const printSimpleReport = (result: CalculationOutput) => {
  console.log("");
  console.log("ðŸ“‹ RAPPORT SIMPLE (RÃ©sumÃ© Rapide)");
  console.log("â”€".repeat(50));
  console.log("Break-even Point (Financing):", result.breakEvenPoint, "years");
  console.log("Break-even Point (Cash):", result.breakEvenPointCash, "years");
  console.log(
    "Total Savings (15 years - Financing):",
    formatCurrency(result.totalSavingsProjected)
  );
  console.log(
    "Total Savings (15 years - Cash):",
    formatCurrency(result.totalSavingsProjectedCash)
  );
  console.log("ROI % (Financing):", result.roiPercentage + "%");
  console.log("ROI % (Cash):", result.roiPercentageCash + "%");
  console.log(
    "Average Yearly Gain (Financing):",
    formatCurrency(result.averageYearlyGain)
  );
  console.log(
    "Average Yearly Gain (Cash):",
    formatCurrency(result.averageYearlyGainCash)
  );
  console.log("â”€".repeat(50));
  console.log("AnnÃ©e 1 donnÃ©es:");
  console.log(
    "- Facture sans solaire:",
    formatCurrency(result.year1.edfBillWithoutSolar)
  );
  console.log(
    "- Total avec solaire:",
    formatCurrency(result.year1.totalWithSolar)
  );
  console.log(
    "- solarSavingsValue:",
    formatCurrency(result.year1.solarSavingsValue)
  );
  console.log("- cashflowDiff:", formatCurrency(result.year1.cashflowDiff));
  console.log("- monthlyEffort:", formatCurrency(result.monthlyEffortYear1));
  console.log("");
};
